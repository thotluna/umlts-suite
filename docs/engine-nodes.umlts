config {
  language: "typescript"
}

package syntax {
  package diagnostic {
    enum DiagnosticSeverity(Error | Warning | Info)

    enum DiagnosticCode(
      SYNTAX_ERROR | 
      SEMANTIC_INHERITANCE_MISMATCH | 
      SEMANTIC_REALIZATION_INVALID | 
      SEMANTIC_CYCLE_DETECTED | 
      SEMANTIC_DUPLICATE_MEMBER | 
      SEMANTIC_INVALID_PACKAGE_RELATIONSHIP | 
      SEMANTIC_INVALID_TYPE | 
      SEMANTIC_IMPLICIT_ENTITY | 
      SEMANTIC_INVALID_REFERENCE | 
      SEMANTIC_INVALID_MULTIPLICITY | 
      SEMANTIC_COMPOSITE_VIOLATION | 
      SEMANTIC_DUPLICATE_ENTITY | 
      SEMANTIC_AMBIGUOUS_ENTITY | 
      SEMANTIC_INVALID_ASSOCIATION_CLASS
    )

    interface Diagnostic {
      message: string
      code: >- DiagnosticCode[0..1]
      line: number
      column: number
      length: number[0..1]
      severity: >- DiagnosticSeverity
    }
  }

  package ast {
    enum ASTNodeType(
      PROGRAM | PACKAGE | CLASS | INTERFACE | ENUM | 
      METHOD | ATTRIBUTE | PARAMETER | RELATIONSHIP | 
      COMMENT | TYPE | CONFIG | ASSOCIATION_CLASS | 
      CONSTRAINT | NOTE | ANCHOR
    )

    interface *ASTNode {
      type: >- ASTNodeType
      line: number
      column: number
      docs: string[0..1]
    }

    interface TypeNode >> ASTNode {
      kind: > EnumKind(simple | generic | array | enum | xor)
      raw: string
      name: string
      arguments: >- TypeNode[0..*]
      values: string[0..*]
    }

    interface ProgramNode >> ASTNode {
      body: >* StatementNode[0..*]
      diagnostics: >* syntax.diagnostic.Diagnostic[0..*]
    }

    /* Base for all nodes that can be in a package or program */
    interface *StatementNode >> ASTNode

    interface NoteNode >> StatementNode {
      value: string
      id: string[0..1]
    }

    interface AnchorNode >> StatementNode {
      from: string
      to: string[0..*]
    }

    interface PackageNode >> StatementNode {
      name: string
      body: >* StatementNode[0..*]
    }

    interface Modifiers {
      isAbstract: boolean[0..1]
      isStatic: boolean[0..1]
      isActive: boolean[0..1]
      isLeaf: boolean[0..1]
      isFinal: boolean[0..1]
      isRoot: boolean[0..1]
    }

    interface EntityNode >> StatementNode {
      name: string
      relationships: >* RelationshipHeaderNode[0..*]
      body: >* MemberNode[0..*]
      modifiers: >- Modifiers
      typeParameters: string[0..*]
    }

    interface RelationshipHeaderNode >> ASTNode {
      kind: string
      target: string
      isNavigable: boolean
      targetModifiers: >- Modifiers[0..1]
    }

    /* Base for all members of an entity */
    interface *MemberNode >> ASTNode

    interface AttributeNode >> MemberNode {
      name: string
      visibility: string
      modifiers: >- Modifiers
      typeAnnotation: >- TypeNode
      multiplicity: string[0..1]
      relationshipKind: string[0..1]
      isNavigable: boolean[0..1]
      label: string[0..1]
      constraints: >* ConstraintNode[0..*]
      targetModifiers: >- Modifiers[0..1]
    }

    interface MethodNode >> MemberNode {
      name: string
      visibility: string
      modifiers: >- Modifiers
      parameters: >* ParameterNode[0..*]
      returnType: >- TypeNode
      returnMultiplicity: string[0..1]
      returnRelationshipKind: string[0..1]
      isNavigable: boolean[0..1]
      constraints: >* ConstraintNode[0..*]
      returnTargetModifiers: >- Modifiers[0..1]
    }

    interface ParameterNode >> ASTNode {
      name: string
      typeAnnotation: >- TypeNode
      relationshipKind: string[0..1]
      isNavigable: boolean[0..1]
      constraints: >* ConstraintNode[0..*]
      targetModifiers: >- Modifiers[0..1]
      multiplicity: string[0..1]
    }

    interface RelationshipNode >> StatementNode {
      from: string
      fromModifiers: >- Modifiers[0..1]
      fromMultiplicity: string[0..1]
      to: string
      toModifiers: >- Modifiers[0..1]
      toMultiplicity: string[0..1]
      kind: string
      isNavigable: boolean
      label: string[0..1]
      constraints: >* ConstraintNode[0..*]
      body: >* MemberNode[0..*]
    }

    interface AssociationClassNode >> StatementNode {
      name: string
      participants: >* Participant[0..*]
      body: >* MemberNode[0..*]
    }

    interface Participant {
      name: string
      multiplicity: string[0..1]
      relationships: >* RelationshipHeaderNode[0..*]
    }

    interface CommentNode >> StatementNode {
      value: string
    }

    interface ConfigNode >> StatementNode {
      options: object
    }

    interface ConstraintNode >> StatementNode {
      kind: string
      targets: string[0..*]
      body: >* StatementNode[0..*]
      expression: string[0..1]
    }
  }
}

package generator {
  package ir {
    interface IRModifiers {
      isAbstract: boolean
      isStatic: boolean
      isActive: boolean
      isLeaf: boolean
      isFinal: boolean
      isRoot: boolean
    }

    enum IREntityType(CLASS | INTERFACE | DATA_TYPE | ENUMERATION | PRIMITIVE_TYPE | ASSOCIATION_CLASS)

    enum IRVisibility(+ | - | # | ~)

    interface IRMultiplicity {
      lower: number
      upper: string // Represents number | '*'
    }

    interface IRParameter {
      name: string
      type: string[0..1]
      multiplicity: >- IRMultiplicity[0..1]
      direction: > EnumDirection(in | out | inout | return)[0..1]
      relationshipKind: string[0..1]
      modifiers: >- IRModifiers[0..1]
    }

    interface IRProperty {
      name: string
      type: string[0..1]
      visibility: >- IRVisibility
      isStatic: boolean
      isReadOnly: boolean
      isLeaf: boolean
      multiplicity: >- IRMultiplicity[0..1]
      isOrdered: boolean
      isUnique: boolean
      aggregation: > EnumAggreg(none | shared | composite)
      label: string[0..1]
      docs: string[0..1]
      constraints: >* IRConstraint[0..*]
    }

    interface IROperation {
      name: string
      visibility: >- IRVisibility
      isStatic: boolean
      isAbstract: boolean
      isLeaf: boolean
      isQuery: boolean
      parameters: >* IRParameter[0..*]
      returnType: string[0..1]
      returnMultiplicity: >- IRMultiplicity[0..1]
      docs: string[0..1]
      constraints: >* IRConstraint[0..*]
    }

    interface IREnumerationLiteral {
      name: string
      docs: string[0..1]
    }

    interface IREntity {
      id: string
      name: string
      type: >- IREntityType
      properties: >* IRProperty[0..*]
      operations: >* IROperation[0..*]
      literals: >* IREnumerationLiteral[0..*]
      isImplicit: boolean
      isAbstract: boolean
      isActive: boolean
      isLeaf: boolean
      isFinal: boolean
      isRoot: boolean
      isStatic: boolean
      typeParameters: string[0..*]
      namespace: string[0..1]
      docs: string[0..1]
    }

    enum IRRelationshipType(
      ASSOCIATION | GENERALIZATION | INTERFACE_REALIZATION | 
      DEPENDENCY | SUBSTITUTION | USAGE | TEMPLATE_BINDING |
      INHERITANCE | IMPLEMENTATION | COMPOSITION | AGGREGATION |
      BIDIRECTIONAL | REALIZATION
    )

    interface IRRelationship {
      from: string
      to: string
      type: >- IRRelationshipType
      fromMultiplicity: >- IRMultiplicity[0..1]
      toMultiplicity: >- IRMultiplicity[0..1]
      fromName: string[0..1]
      toName: string[0..1]
      isNavigable: boolean
      label: string[0..1]
      visibility: >- IRVisibility[0..1]
      associationClassId: string[0..1]
      docs: string[0..1]
      constraints: >* IRConstraint[0..*]
    }

    interface IRConstraint {
      kind: string
      targets: string[1..*]
      expression: string[0..1]
    }

    interface IRDiagram {
      entities: >* IREntity[0..*]
      relationships: >* IRRelationship[0..*]
      constraints: >* IRConstraint[0..*]
      configuration: object[0..1]
    }
  }
}
