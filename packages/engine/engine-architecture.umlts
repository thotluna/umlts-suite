@language: typescript

config {
  theme: dark
  direction: DOWN
}

package Engine {
  
  class UMLEngine {
    -factory : >* PhasesFactory
    -phases : >- CompilerPhase[0..*]
    +parse(source: String): ParseResult
  }

  package Compiler {
    class PhasesFactory {
      +getPhases(): CompilerPhase[0..*]
    }

    interface CompilerPhase {
      +run(context: CompilerContext, artifacts: PipelineArtifacts)
    }

    class LexerPhase >I CompilerPhase {
      -lexer : >- Lexer
    }
    class ParserPhase >I CompilerPhase {
      -parser : >- Parser
    }
    class SemanticPhase >I CompilerPhase {
      -analyzer : >* SemanticAnalyzer
    }

    class Lexer {
      -matchers : >* TokenMatcher[0..*] // Core Matchers (e.g. Standard UML)
      +tokenize(): Token[0..*]
    }

    interface TokenMatcher {
      +match(reader: LexerReader): Token
    }

    class Parser {
      -rules : >* ParserRule[0..*] // Core Rules
      +parse(tokens: Token[0..*]): ProgramNode
    }

    interface ParserRule {
      +canHandle(context: ParserHub): Boolean
      +parse(context: ParserHub): Node[0..*]
    }
    
    class ParserHub
    
    class CompilerContext {
      +source : String
      +diagnostics : Diagnostic[0..*]
    }
  }

  package Semantics {
    class SemanticAnalyzer {
      -orchestrator : >* SemanticPipelineOrchestrator
      -services : >* SemanticServicesProvider
      +analyze(program: ProgramNode, context: ISemanticContext): IRDiagram
    }

    class SemanticPipelineOrchestrator {
      -pipeline : >* SemanticPipeline
      +execute(program: ProgramNode, state: ISemanticState)
    }

    class SemanticPipeline {
      -passes : >* ISemanticPass[0..*]
      +execute(program: ProgramNode, state: ISemanticState)
    }

    interface ISemanticPass {
      +execute(program: ProgramNode, state: ISemanticState)
    }

    class DiscoveryPass >I ISemanticPass
    class DefinitionPass >I ISemanticPass
    class ResolutionPass >I ISemanticPass

    class SemanticServicesProvider {
      +getEntityAnalyzer(): EntityAnalyzer
      +getRelationshipAnalyzer(): RelationshipAnalyzer
      +getValidationEngine(): ValidationEngine
      +getMemberInference(): MemberInference
    }

    class SymbolTable {
      +register(entity: IREntity)
      +resolveFQN(name: String): String
      +getAllEntities(): IREntity[0..*]
    }

    class ValidationEngine {
      +execute(target: Target, data: Any, context: ISemanticContext)
    }

    class MemberInference {
      -state : ISemanticState
      -relAnalyzer : RelationshipAnalyzer
      +run()
    }
  }

  package Infrastructure {
    class AnalysisSession >I ISemanticState {
      +symbolTable : SymbolTable
      +relationships : IRRelationship[0..*]
      +configStore : ConfigStore
    }

    interface ISemanticState {
      +recordRelationship(rel: IRRelationship)
    }

    class ConfigStore {
      // -config : Map<String, Any>
      +merge(options: Map)
    }
  }
}
